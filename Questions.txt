Q) Which are legal:
A) { int x; }
   { int x; }
B) class X {
     { sout(x); } // sout means System.out.println ...
     int x;
   }
C) {
     int x;
     { int x; }
   }
D) {
     int x;
     Predicate<String> ps = x -> true;
   }
E) for (int x = 0; x < 10; x++)
     ;
    int x;

Q) Which are legal:
   A) class X {
     var x = 99;
   }

   B) void doStuff(var x) { }

   C) void doStuff() {
     var x;
     x = 100;
   }
   D) void doStuff() {
     var x = 100;
   }

   E) void doStuff() {
     var x = { 1, 2, 3 };
   }

Q) Which are legal:
   A) void doStuff() {
     var x = new int[]{ 1, 2, 3 };
   }
   B) void doStuff() {
     var [] x = new int[]{ 1, 2, 3 };
   }
   C) void doStuff() {
     var x = 99;
     x = "Hello";
   }
   D) void doStuff() {
     var x = 1, y = 2;
   }
   E)
   void doStuff() {
     try {
      // stuff happens
      } catch (var ex) {
      }
   }

Q) Which are legal
   A)
      for (var x = 0; x < 3; x++)
        System.out.println(x);
   B)
      try (var in = new FileReader("");
           var out = new FileWriter("")) {
      }
   C)
      var var = "var";

Q)   Which print "true"
   A) String s = "Hello";
      String t = "He";
      t += "llo";
      sout(s == t);
   B) String s = "Hello";
      String t = "He";
      t += "llo";
      sout(s.equals(t));
   C) StringBuilder s = new StringBuilder("Hello");
      StringBuilder t = new StringBuilder("He");
      t.append("llo");
      sout(s.equals(t));
   D) List<String> ls = List.of("Fred", "Jim");
      List<String> ls2 = new ArrayList<>(ls);
      sout(ls.equals(ls2));
   E) LocalDate ld = LocalDate.of(2021, 3, 29);
      LocalDate ld2 = LocalDate.of(2021, 3, 29);
      sout(ld.equals(ld2));

Q)
Given:
class X {
  static String h = "Hello";
}
and:
     String s1 = "Hello";
     String s2 = new StringBuilder("Hello").toString();
     String s3 = s2.intern();

Which are true?
A) s1 == s2
B) s2 == s3
C) s1 == s3
D) X.h == s1

Q) Which are valid?
     A) int x = 99; while (x) {}
     B) int x = 99; switch (x) {}
     C) enum Day { MONDAY; }
   ...
     Day x = Day.MONDAY;
   switch (x) {
       case MONDAY:
     }
     D) enum Day { MONDAY; }
   ...
     Day x = Day.MONDAY;
   switch (x) {
       case Day.MONDAY:
     }
     E) long count = 99;
   switch (count) {}

Q) Given
     void doStuff() throws IOException {};
     void doStuff2() throws FileNotFoundException {};
   And:
     void tryStuff() {
       try {
         doStuff();
         doStuff2();
       } enter code here { // handle both exceptions
       }
     }
   What can be inserted at "enter code here"
   to provide handling of exceptions from both
   methods?
A) catch (IOException | FileNotFoundException e)
B) catch (FileNotFoundException | IOException e)
C) catch (FileNotFoundException e)
D) catch (IOException e)
E) finally

Q) Given class AC implements AutoCloseable {
     private String name; // constructor initializes name
     public void close() { System.out.println("Closing " + name); } }
And:
       var ac0 = new AC("zero");
       try ( var ac1 = new AC("one");
           var ac2 = new AC("two");
           ac0;){
       }
     }
What is the result?
   A) Compilation fails
   B) Closing zero Closing two Closing one
   C) Closing zero Closing one Closing two
   D) Closing two Closing one Closing zero
   E) Closing one Closing two Closing zero

Q) Given
     void doStuff(int x, int y) {}         // Method A
     void doStuff(int x, long y) {}        // Method B
     void doStuff(long x, int y) {}        // Method C
     void doStuff(int ... x) {}            // Method D
     void doStuff(Integer x, Integer y) {} // Method E

which method will be invoked by this call:
       doStuff(1, 2);

Q) Given
     void doStuff(int x, int y) {}         // Method A
     void doStuff(int x, long y) {}        // Method B
     void doStuff(long x, int y) {}        // Method C
     void doStuff(int ... x) {}            // Method D
     void doStuff(Integer x, Integer y) {} // Method E

if method A is removed, what is the result of this call:
       doStuff(1, 2);

A) Compilation fails
B) method B is invoked
C) method C is invoked
D) method D is invoked
E) method E is invoked

Q) Given
     void doStuff(int x, int y) {}         // Method A
     void doStuff(int x, long y) {}        // Method B
     void doStuff(long x, int y) {}        // Method C
     void doStuff(int ... x) {}            // Method D
     void doStuff(Integer x, Integer y) {} // Method E

if methods A, B, and C are removed, what is the result of this call:
       doStuff(1, 2);

A) Compilation fails
D) method D is invoked
E) method E is invoked

